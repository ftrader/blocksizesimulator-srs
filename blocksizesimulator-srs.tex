%Software Requirements Specification for Adjustable Blocksize Limit Scenario Simulator

%Based on SRS-Tex template:
%Copyright 2014 Jean-Philippe Eisenbarth
%This program is free software: you can
%redistribute it and/or modify it under the terms of the GNU General Public
%License as published by the Free Software Foundation, either version 3 of the
%License, or (at your option) any later version.
%This program is distributed in the hope that it will be useful,but WITHOUT ANY
%WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
%PARTICULAR PURPOSE. See the GNU General Public License for more details.
%You should have received a copy of the GNU General Public License along with
%this program.  If not, see <http://www.gnu.org/licenses/>.

%Based on the code of Yiannis Lazarides
%http://tex.stackexchange.com/questions/42602/software-requirements-specification-with-latex
%http://tex.stackexchange.com/users/963/yiannis-lazarides
%Also based on the template of Karl E. Wiegers
%http://www.se.rit.edu/~emad/teaching/slides/srs_template_sep14.pdf
%http://karlwiegers.com
\documentclass{scrreprt}
\usepackage{listings}
\usepackage{underscore}
\usepackage[bookmarks=true]{hyperref}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\hypersetup{
    bookmarks=false,    % show bookmarks bar?
    pdftitle={Software Requirement Specification},    % title
    pdfauthor={Jean-Philippe Eisenbarth},                     % author
    pdfsubject={TeX and LaTeX},                        % subject of the document
    pdfkeywords={TeX, LaTeX, graphics, images}, % list of keywords
    colorlinks=true,       % false: boxed links; true: colored links
    linkcolor=blue,       % color of internal links
    citecolor=black,       % color of links to bibliography
    filecolor=black,        % color of file links
    urlcolor=purple,        % color of external links
    linktoc=page            % only page is linked
}%
\def\myversion{0.1 }
\date{}
%\title{%

%}
\usepackage{hyperref}
\begin{document}

\begin{flushright}
    \rule{16cm}{5pt}\vskip1cm
    \begin{bfseries}
        \Huge{SOFTWARE REQUIREMENTS\\ SPECIFICATION}\\
        \vspace{1.9cm}
        for\\
        \vspace{1.9cm}
        Adjustable Blocksize Limit Scenario Simulator\\
        \vspace{1.9cm}
        \LARGE{Version \myversion (draft)}\\
        \vspace{1.9cm}
        Prepared by Bitcoin Cash developers\\
        \vspace{1.9cm}
        \today\\
    \end{bfseries}
\end{flushright}

\tableofcontents


\chapter*{Revision History}

\begin{center}
    \begin{tabular}{|c|c|c|c|}
        \hline
	    Name & Date & Reason For Changes & Version\\
        \hline
	    imaginary_username & 2019-05-12 & initial requirements & 0.0\\
        \hline
	    freetrader & 2019-05-13 & initial SRS draft & 0.1\\
        \hline
    \end{tabular}
\end{center}

\chapter{Introduction}


\section{Purpose}
This document describes all the requirements for a blocksize simulator
(hereafter shortened to `simulator').

These requirements do not yet map to an actual implementation release
as the simulator has not yet been developed.

This SRS describes the entire simulator system.


\section{Document Conventions}
To be completed (TBC)


\section{Intended Audience and Reading Suggestions}
This document is intended for software developers and users of the simulator.

Software developers are encouraged to develop their own implementations based
on these requirements.

Users may find the requirements useful to understand what the simulator is
intended to do.



\section{Project Scope}
The purpose of the simulator is to test a narrow class of adjustable
blocksize schemes for Bitcoin Cash, where consensus blocksize limits are
adjusted with only constants and actual blocksizes as inputs.

Using a simplified model of a Bitcoin Cash network comprised of resource-constrained
but upgradeable mining and service nodes, and including sources of `legitimate'
and `spam' transactions as well as `poison block' providers, the simulator is
intended to provide information on the following observables:

\begin{itemize}
\item response characteristics of various dynamic blocksize algorithms
\item induced transaction delays in face of full blocks (whether from legit or spam traffic)
\item memory pool (mempool) desynchronization
\item network splits
\item node downtime (both service and mining)
\item upgrade feasibility
\item cost needed for a malicious actor to incur damage to the network
\end{itemize}


\section{References}
TBC


\chapter{Overall Description}


\section{Product Perspective}
The simulator is intended to inform the selection of a dynamic blocksize algorithm
for Bitcoin Cash.

It is intended to be standalone, self-contained, easily adaptable and
re-usable in future.

Test scenarios and algorithms subjected to simulation may be maintained
outside of the simulator project.


\section{Product Functions}
Basic description of the main functions:
\begin{itemize}
\item Interpret command line arguments provided by user to start a simulation run
\item Read scenario inputs from user-provided text files
\item Optionally, generate a block history as initial condition for the simulation
\item Run the network simulation for n blocks, optionally outputting traces to console or log file
\item Stop and output simulation results (to console or disk)
\end{itemize}



\section{User Classes and Characteristics}
The simulator is intended to be used by anyone with an interest in Bitcoin Cash
dynamic blocksize algorithms.

This includes protocol developers, miners, service providers and hobbyists.

Operation of the simulator will require only editing of text files and issuance of
commands in a shell (i.e. at least initially it will be an interpreted command line
program).

Interpretation of the simulator output will likely require domain expert knowledge.


\section{Operating Environment}
The simulator is intended to run on standard commodity personal computer hardware
equipped a suitable interpreter and any required libraries.


\section{Design and Implementation Constraints}
TBC

\section{User Documentation}
TBC


\section{Assumptions and Dependencies}
TBC


\chapter{External Interface Requirements}

\section{User Interfaces}
Initially, the simulator user interface will be text console driven with input
provided by command line and configuration text files, and output written to
console and/or disk.

\section{Hardware Interfaces}
None.

\section{Software Interfaces}
The software is stand-alone and uses OS facilities for console and file I/O.

No other software interfaces are planned.

\subsection{Scenario Files}
It is determined they will exist, but:

Precise structure: To be decided (TBD)

\subsection{Blocksize algorithms}
To be specified as an interface which has to be implemented for a node.
It will have access to the node's view of the blockchain in order to make
its calculations based on past block sizes.

The same algorithm will be used by all the nodes in a simulation run.

\section{Communications Interfaces}
None.


\chapter{System Features}

This section describes the main features of the simulation and lists the
functional requirements associated with them.



\section{Feature: General}

\subsection{Priority}

High

\subsection{Description}

This section describes general requirements which are not related to
specific features.


\subsection{Stimulus/Response Sequences}

The simulation runs must be deterministic to allow reproduction.

As some random processes are modeled, a random number generator must be
initialized with a seed that is made known to the user.

A specific seed can also be provided by the user as part of the scenario
(optionally overriden via command line to simplify repeat trials of the
a particular scenario under randomness).


\subsection{Functional Requirements}


\subsubsection{BLOCKSIM-GENERAL-REQ-1 (RNG seed)}

The simulation shall initialize a random number generator (RNG) with a seed
provided by the user in the scenario or on the command line.

If no seed is provided, a seed will be generated from some local machine
parameters and the epoch time, and the seed will be printed to allow
a re-run by the user.

\subsubsection{BLOCKSIM-GENERAL-REQ-2 (termination condition)}

The simulation shall terminate once a block of specified height has been
evaluated by each node.

Example: stop once all nodes have processed 10,000 blocks.

Once the simulator stops, it outputs some statistics (see Output feature).

This setting shall have no default - the simulator shall abort prior
to starting and complain if no block height at which to stop has been
specified in the scenario or on the command line.

\subsubsection{BLOCKSIM-GENERAL-REQ-3 (accounting unit)}

Certain entities in the simulation need to account economically for
their actions.

This applies at minimum to poison block spammers, mining and service nodes.

For these calculations, the simulation shall use a fictional unit of account:
the Sim Dollar, amounts of which are denoted in output by a preceding dollar sign.


\section{Feature: Network}

\subsection{Priority}

High


\subsection{Description}

The simulation requires modeling of a network layer on which
transactions and blocks are transported.


\subsection{Stimulus/Response Sequences}

Traffic generators create transactions which are relayed to all nodes.

Mining nodes create blocks which are relayed to all other nodes (mining, service and generic).

Propagation time of transactions and blocks is not modeled (at least, initially).

That means blocks and transactions take only the minimum amount of time (1 second) to
reach other entities in the simulation.


\subsection{Functional Requirements}


\subsubsection{BLOCKSIM-NETWORK-REQ-1 (instantaneous transaction dissemination)}

Any transactions added to the network by traffic generators at a specific time step shall be inserted into the receive
queue of all nodes instantaneously (at the current simulation time step).

\subsubsection{BLOCKSIM-NETWORK-REQ-2 (instantaneous block dissemination)}

Any block added to the network by a mining node at a specific time step shall be inserted into the receive
queue of all other nodes instantaneously (at the current simulation time step).



\section{Feature: Time}

\subsection{Priority}

High


\subsection{Description}

The simulation requires modeling of time (for example w.r.t. the
processing of blocks by nodes).

Certain attributes of simulation entities such as rates of transactions
created by traffic generators, or processing units required by a node
to validate a transaction or block, may be specified most naturally in terms
of some units per time.

Traffic generators will generate transactions to be inserted at a given time
in the simulation (which depends on each generator's characteristics).

Miners will stochastically generate blocks (provided they have transactions
in their mempool). Once a miner finds a block, it adds that block onto
the network immediately.


\subsection{Stimulus/Response Sequences}

The smallest time unit of the simulator will be fixed.


\subsection{Functional Requirements}


\subsubsection{BLOCKSIM-TIME-REQ-1 (simulation time unit)}

The smallest time unit in the simulation will be one (1) second.

\subsubsection{BLOCKSIM-TIME-REQ-2 (meaning of negative/positive and zero sim times)}

The starting time of the simulation will be referred to as time zero
(t=0), all future events will have an integer simulation time $>$ 0
assigned to them.

Events described in scenarios must be expressed in terms of this
simulation time.

Events which occur before the simulation start (e.g. pre-existing blocks
which as part of initial conditions) shall have negative integer simulation
times assigned to them (e.g. t=-1, t=-43, etc.)



\section{Feature: Scenarios}

\subsection{Priority}

High


\subsection{Description}

A scenario completely defines all the inputs for a simulation run.

It may be specified in one single file or a collection of files (TBD),
but in either case there shall be one single file that acts as the
main starting point to provide the input data used in a simulator run.

Some example scenario files can be provided with the base simulator.

Editing scenario files is outside the scope of this SRS. As they will be pure
text files, it can be left to the user and their favorite text editor.


\subsection{Stimulus/Response Sequences}

When users start the simulator, they will need to specify the (main)
scenario file on the command line.

The simulator processes the scenario file and any potential dependencies.

If there are no errors (such as missing or invalid data), the simulation
will run, otherwise the simulator should exit with appropriate error messages.


\subsection{Functional Requirements}


\subsubsection{BLOCKSIM-SCENARIO-REQ-1 (starting scenario file)}

The simulator shall read in the scenario file provided on the command line and
automatically process any dependencies (further included scenario files).


\subsubsection{BLOCKSIM-SCENARIO-REQ-2 (abort if invalid/incomplete scenario handling)}

The simulator shall abort if any required input information is missing or
invalid after processing the scenario file(s).

\subsubsection{BLOCKSIM-SCENARIO-REQ-3 (inform which data is invalid/incomplete)}
Any missing/invalid scenario information shall be listed to the user to enable
them to adequately configure the scenario.


\subsubsection{BLOCKSIM-SCENARIO-REQ-4 (list of scenario data items)}
Input data items specified by scenario shall be as follows
(the list below should be complete):

TODO: some may be optional - need to describe better

\begin{enumerate}
\item Seed for RNG initialization. This may be overridden by a command line parameter.
\item block height at which to terminate the simulation. This may be overridden by a command line parameter.
\item Blocksize algorithm to use in nodes (this also defines the `hard' max blocksize for a node)
\item Definition of the node population
   \begin{enumerate}
   \item Number of mining nodes
   \item Number of service nodes
   \item Number of generic nodes (optional - generic nodes would be non-mining, non-service nodes)
   \item Default node mempool size (in bytes)
   \end{enumerate}
\item Definition of the mining nodes
\item Definition of the service nodes
\item Definition of the traffic generators (these are not nodes, but sources which inject transactions traffic into the simulation)
   \begin{enumerate}
   \item sources of `legit' transactions
   \item sources of `spam' transactions
   \end{enumerate}
\end{enumerate}



\section{Feature: Node class}
\subsection{Priority}

High

\subsection{Description}

The node class provides the base from which all node types in the
system (i.e. mining, service, generic nodes) are derived.


\subsection{Stimulus/Response Sequences}

After the scenario has been read and validated, the simulator will
instantiate node objects of the specified types before starting the
simulation.

Specialized node types may override some of the resource attributes
of the node base class.

Node objects maintain their own mempool and view of the blockchain history,
and receive transactions (from traffic generators) and blocks (from miners)
for processing.

If their resources are exceeded during simulated operation, nodes
become unavailable (`downtime`) and may require simulated maintenance (TBD).

The transactions in received blocks must be entered into the node's mempool
before the block can be processed.

Blocks that have been stuck on a Poison block for too long must be able to
fall back to processing another legitimate block instead.

Validation time of received transactions (as opposed to blocks) before
entering a node's mempool is not modeled explicitly.

\subsection{Functional Requirements}

\subsubsection{BLOCKSIM-NODE-BASE-REQ-0 (node type identifier)}

Each nodes shall be identified by an attribute as one of the following types:

\begin{itemize}
   \item mining node
   \item service node
   \item generic node
\end{itemize}



\subsubsection{BLOCKSIM-NODE-BASE-REQ-1 (mempool per node)}

Nodes shall maintain their own mempool containing transactions already seen
but not removed by a block in the node's active blockchain history.


\subsubsection{BLOCKSIM-NODE-BASE-REQ-2 (blockchain history per node)}

Nodes shall maintain their own history of the blockchain, as a list of
linked blocks which the node has been able to `validate`.

\subsubsection{BLOCKSIM-NODE-BASE-REQ-3 (validation rate per node)}

Nodes shall have an overrideable attribute which defines a processing rate
at which they are able to validate blocks.

This rate may be defined in terms of some unit (e.g. some `cycles` or `ops`)
used by blocks to specify their validation cost.

\subsubsection{BLOCKSIM-NODE-BASE-REQ-4 (input queue for blocks)}

Nodes shall maintain a queue for blocks received from miners but not
yet validated.

NOTE: this may include both reasonably sized blocks, and `poison blocks`
which are blocks whose validation may not be reasonably achieved by a
node within a 10 minute timeframe.

\subsubsection{BLOCKSIM-NODE-BASE-REQ-5 (nodes validate blocks in parallel)}

Nodes shall validate received blocks in parallel according to their
configured validation rates and the validation cost of each block.

Such validation is subject to mempool constraints.

Once a node has validated a block at a given height, it aborts validation
of other candidate blocks for the same height.

\subsubsection{BLOCKSIM-NODE-BASE-REQ-6 (mempool space required for block validation)}

Validation is subject to mempool constraints.
Transactions not already received into the mempool (e.g. those in a `poison block`)
must be entered into node mempool before the block can be validated.

NOTE: as per general node requirements, if the mempool capacity is reached
the node is considered to have gone down (into maintenance).

\subsubsection{BLOCKSIM-NODE-BASE-REQ-7 (abort blocks $>$ 10 minutes)}

If a node is unable to process a block within a simulation time of 10 minutes,
it shall abort the processing of that block.

NOTE: This applies particular to `poison block` processing, and models
at cut-off time at which a node gives up on validating such a block.

\subsubsection{BLOCKSIM-NODE-BASE-REQ-8 (node mempool cap must $>$ node max blocksize)}

A node's configured mempool capacity shall exceed the configured
maximum blocksize that can be processed by the node, otherwise a fatal
misconfiguration error shall be reported and the simulation aborted.



\section{Feature: Mining nodes}

\subsection{Priority}

High

\subsection{Description}

Mining nodes are derived from generic nodes. They inherit all the
attributes and behaviors except as defined by the additional functional
requirements below.

The main additional capability is to produce blocks.

These blocks also generate revenue for the mining node by way of the
fees from transactions in a mined block.


\subsection{Stimulus/Response Sequences}

As a simplification, hashpower and difficulty are not modeled, therefore
all mining nodes that are not `down' will have an equal chance of finding
the next block (hashpower of all nodes is assumed equal, and difficulty
is assumed such that the next block will be found on average within 10
minutes).


\subsection{Functional Requirements}


\subsubsection{BLOCKSIM-NODE-MINING-REQ-1 (nodes hash at equal rates)}

At the initialization of the simulation run, each mining node shall be
assigned a `hashpower` fraction equivalent to 1/M where M is the total number
of mining nodes specified (and active) at the start.

NOTE: This ensures that each node has an equal chance of producing
the next block and allows mining of regular blocks to slow down as the
network may be impeded by adversarial action that impact mining nodes.
The difficulty adjustment which would compensate a loss of hashpower
in such a case, is not modeled.

\section{Feature: Service nodes}

\subsection{Priority}

TBD

\subsection{Description}

Service nodes are used to model economic service providers, and thus
are simulated with a focus on measuring cost of downtime and feasibility
of upgrades, similar to mining nodes, despite service nodes not generating
any blocks.

Service nodes generate revenue which is accounted, modeled as a function of
`legit` transactions they successfully process.

NOTE: The revenue/cost calculation formulas are elaborated in the functional
requirements of this feature section.

This includes both validated transactions accepted into mempool as well as
the transactions in blocks.

Service nodes also accrue maintenance costs, modeled as a function of certain
capacities of the node over time.


\subsection{Stimulus/Response Sequences}

$<$Insert known stimuli/responses$>$


\subsection{Functional Requirements}

\subsubsection{BLOCKSIM-NODE-SERVICE-REQ-1 (revenue formula)}

TBD


\subsubsection{BLOCKSIM-NODE-SERVICE-REQ-2 (cost of maintenance formula)}

TBD



\section{Feature: Generic nodes}

\subsection{Priority}

Low

\subsection{Description}

Generic nodes are neither mining nor economic nodes, and are modeled
after relay nodes which have no specific purpose.

Simulating them may not be particularly useful, but might give some
insight at what level of network utilization the low-spec nodes will
drop out.


\subsection{Stimulus/Response Sequences}

Generic nodes process incoming transactions and blocks as they are
produced.

They do not need revenue / cost of maintenance accounting.

The statistics tracked are inherited from the base node class.

Also, the basic node rules for processing blocks and for dropping out due to
exceeded mempool capacity apply.


\subsection{Functional Requirements}

\subsubsection{BLOCKSIM-NODE-GENERIC-REQ-1 (short title)}

$<$Insert requirement text$>$





\section{Feature: Transactions}

\subsection{Priority}

TBD

\subsection{Description}

$<$Insert feature description$>$


\subsection{Stimulus/Response Sequences}

$<$Insert known stimuli/responses$>$


\subsection{Functional Requirements}

\subsubsection{BLOCKSIM-TRANSACTIONS-REQ-1 (short title)}

$<$Insert requirement text$>$





\section{Feature: Blocks}

\subsection{Priority}

TBD

\subsection{Description}

$<$Insert feature description$>$


\subsection{Stimulus/Response Sequences}

$<$Insert known stimuli/responses$>$


\subsection{Functional Requirements}

\subsubsection{BLOCKSIM-BLOCKS-REQ-1 (short title)}

$<$Insert requirement text$>$





\section{Feature: Traffic generators}

\subsection{Priority}

TBD

\subsection{Description}

$<$Insert feature description$>$


\subsection{Stimulus/Response Sequences}

$<$Insert known stimuli/responses$>$


\subsection{Functional Requirements}

\subsubsection{BLOCKSIM-TRAFFICGEN-REQ-1 (short title)}

$<$Insert requirement text$>$





\section{Feature: Node upgrades}

\subsection{Priority}

Medium

\subsection{Description}

$<$Insert feature description$>$


\subsection{Stimulus/Response Sequences}

$<$Insert known stimuli/responses$>$


\subsection{Functional Requirements}

\subsubsection{BLOCKSIM-UPGRADES-REQ-1 (short title)}

$<$Insert requirement text$>$





\section{Feature: Outputs}

\subsection{Priority}

High


\subsection{Description}

The simulation requires output of runtime traces (for troubleshooting or
self tests) and some collected and aggregated data (for user evaluation of
simulator scenario results).


\subsection{Stimulus/Response Sequences}

Some of the output events are triggered during the simulation, but the
main output


\subsection{Functional Requirements}


\subsubsection{BLOCKSIM-OUTPUTS-REQ-1 (list of output statistics)}

After the simulation has concluded, the following statistics shall be output
to the user:

\begin{enumerate}
\item Remaining mining nodes
\item Remaining service nodes
\item Aggregate delay for `legit' transactions: number of transactions x number of blocks before inclusion
\item Aggregate time where > 50 percent of mempools are desynchronized
\item Cost incurred by spammer
\item Cost incurred by Poison blockers: if block is orphaned, assume the entire block reward is razed for the attacker
\item Maximum numbers of blocks that are re-organized during the simulation
\item Total upgrade cost
\item Total revenue
\end{enumerate}


\chapter{Other Non-functional Requirements}

\section{Performance Requirements}
TBD

Should be described in terms of feasible network sizes of interest (up to 2000 nodes?),
realistic mempool capacity distributions, transaction generation rates and simulation
time ranges possible on a reasonably modern multi-core PC with disk and memory specs,
available to COTS hardware.


\section{Safety Requirements}
None.

\section{Security Requirements}
None.

\section{Software Quality Attributes}
It is important the simulator be easily configurable and adaptable.

Python is recommended as it is widely available across platforms and supported
by common development environments.

Most Bitcoin Cash developers would be able to do the Python programming needed
to implement further blocksize algorithms for testing, and even enhancements
to the simulator.

Python provides good libraries and unit testing facilities, and also modules
for a possible GUI that could be constructed to make handling the simulator
easier in future.


\section{Business Rules}
None.


\chapter{Other Requirements}
None / TBD.

\section{Appendix A: Glossary}
%see https://en.wikibooks.org/wiki/LaTeX/Glossary
$<$Define all the terms necessary to properly interpret the SRS, including
acronyms and abbreviations. You may wish to build a separate glossary that spans
multiple projects or the entire organization, and just include terms specific to
a single project in each SRS.$>$

\section{Appendix B: Analysis Models}
$<$Optionally, include any pertinent analysis models, such as data flow
diagrams, class diagrams, state-transition diagrams, or entity-relationship
diagrams.$>$

\section{Appendix C: To Be Determined List}
$<$Collect a numbered list of the TBD (to be determined) references that remain
in the SRS so they can be tracked to closure.$>$

\section{Appendix D: To Do List}
This is a list of changes that still need to be taken into account in
future iterations of this specification.

\begin{itemize}
   \item TODO
\end{itemize}


\end{document}
